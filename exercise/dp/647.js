// 647. 回文子串
// 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

// 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。



// 示例 1：

// 输入："abc"
// 输出：3
// 解释：三个回文子串: "a", "b", "c"
// 示例 2：

// 输入："aaa"
// 输出：6
// 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"

// 判断一个字符串是回文字符串，首先要明确什么是回文字符串。我理解回文字符串是中心对称的字符串，比如"a", "bab", "baab"。

// 判断逻辑是从中心往左往右字符串一致。

// 可以对每个字符，作为中心，往两侧循环判断。

// 对于字符串'baccab'有c, c, cc, acca, baccab这5个结果。

// 可知一部分结果依赖于另一部分结果。比如cc依赖于c和c。acca依赖于cc。

// 如何考虑使用动态规划呢？dp为二维数组,dp[i][j]表示i到j之间的字符串是否为回文字符串。

// 在 s[i] === s[j]时，
// 1.当j - i = 0时，是回文字符串，示例a。
// 2.当j - i = 1时，局部字符串长度是2，也是回文字符串，示例aa。
// 3.当j - i = 2时，局部字符串长度是3时，也是回文字符串，示例aba。
// 4.当j - i = 3时，局部字符串长度是4时，示例abca, 需要s[i + 1] === s[j - 1]才行。
// 5.当j - i = 4时，局部字符串长度是5时，示例abcba, 需要s[i + 1] === s[j - 1]才行。
// 6.当j - i = 5时，局部字符串长度是6时，示例abccba, 需要s[i + 1] === s[j - 1]，还需要s[i + 2] === s[j - 2]，但是这个在第5点里面已经判断过了，因此只要判断最近1层的即可。
// 推到下状态转移方程：d[i][j] = s[i] === s[j] && ((j-i)<20 || dp[i+1][j-1])

// 提示：

// 输入的字符串长度不会超过 1000 。


/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function (s) {
  const len = s.length
  const dp = new Array(len)
  let count = 0
  for (let i = 0; i < len; i++) {
    dp[i] = new Array(len).fill(false)
  }

  for (let j = 0; j < len; j++) {
    for (let i = 0; i <= j; i++) {
      if(s[i] === s[j]){
        if ((j - i) < 2 || dp[i+1][j-1]){
          dp[i][j] = true
          count++
        }
      }
    }
  }
  return count
}
countSubstrings("aa")
