## 排序

稳定性：任意两个相等的数据，排序后的相对顺序不变

以下例子都是按照升序排序。

### 冒泡排序

思路:对于一个乱序数组，第一次循环找出最大的放到最后一个位置，第二次循环找出第二大的放到倒数第二个位置，第三次找到倒数第三大的放到倒数第三个位置。

如何找出一次循环范围中最大的元素？两两比较，永远把大的放到后面。

最好复杂度O(n)

最坏复杂度O(n2)

稳定排序


### 插入排序

思路：假设手中已经有了第一张牌，然后开始摸牌，每次摸进来都要和手上当前的牌两两从后开始比较，直到按照到从到大放到有序的位置插入。

最好复杂度O(n)

最坏复杂度O(n2)

稳定排序

复杂度和逆序对的个数有关，以上两种算法平均复杂度是O(n2)

### 希尔排序

思路：在插入排序的基础上，不是相邻元素两两比较，而是每N个间隔排序。

n的选取用互质元素序列。

### 选择排序

思路：每次找到最小的元素放到当前排序后的位置


### 堆排序
 
思路：在选择排序的基础上，找最小的元素不用循环这样的O(n)的复杂度的数据，而用最小堆O(logn)这样的复杂度的数据。

最小堆：每次取出最小的排序

最大堆：每次把数据按照最大堆进行排序，然后再把最大元素和堆尾交换，直接在堆上不断排序。

复杂度O(nlogn)

### 归并排序

递归实现思路：把数组分为左右两部分，分而治之，左右两部分都排好序后，在合并排序。递归的基线条件是左右两部分都只包含一个元素。

非递归实现思路：把数组按照每组2个元素分组，然后组内排好序后，再按照4个元素分组，再组内排好序，在不断递增组的大小，直到数组一半的规模，再合并。